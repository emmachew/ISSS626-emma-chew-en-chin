---
title: "Hands-on Exercise 2"
author: "Emma Chew En Chin"
date: "Aug 28, 2025"
date-modified: "last-modified"
format: html
execute: 
  echo: true
  eval: true
  warning: false
  freeze: true
---

## 1 Thematic Mapping and Geovisualisation

```{r}
pacman::p_load(sf, tmap, tidyverse, rvest)
```

## 2 Importing Geospatial Data

```{r}
mpsz <- st_read("data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml")
```

### 2.1 Tidying Data

**Input Validation:** First checks if the input HTML text is NA or empty, returning NA immediately if true.

**HTML Parsing:** Uses `read_html()` from the rvest package to parse the HTML text.

**Table Row Extraction:** Finds all table rows `<tr>`

elements) in the HTML.

**Field Matching:** Filters the rows to find the one where the table header `<tr>` text matches the requested field_name.

**Value Extraction:** Extracts the text content from the corresponding table data cell `<td>` in the matching row.

**Result Handling:** Returns the extracted value, or NA if the field wasn't found.

```{r}
extract_kml_field <- function(html_text, field_name) {
  if (is.na(html_text) || html_text == "") return(NA_character_)
  
  page <- read_html(html_text)
  rows <- page %>% html_elements("tr")
  
  value <- rows %>%
    keep(~ html_text2(html_element(.x, "th")) == field_name) %>%
    html_element("td") %>%
    html_text2()
  
  if (length(value) == 0) NA_character_ else value
}
```

```{r}
mpsz <- mpsz %>%
  mutate(
    REGION_N = map_chr(Description, extract_kml_field, "REGION_N"),
    PLN_AREA_N = map_chr(Description, extract_kml_field, "PLN_AREA_N"),
    SUBZONE_N = map_chr(Description, extract_kml_field, "SUBZONE_N"),
    SUBZONE_C = map_chr(Description, extract_kml_field, "SUBZONE_C")
  ) %>%
  select(-Name, -Description) %>%
  relocate(geometry, .after = last_col())
```

```{r}
mpsz
```

## 3 Importing Attribute Data

```{r}
popdata <- read_csv("data/aspatial/respopagesexfa2024.csv")
```

### 3.1 Data Preparation

A data table of 2020 values is prepared, which includes the variables `PA`, `SZ`, `YOUNG`, `ECONOMY ACTIVE`, `AGED`, `TOTAL`, `DEPENDENCY`.

`YOUNG`: age group 0 to 4 until age groyup 20 to 24, `ECONOMY ACTIVE`: age group 25-29 until age group 60-64, `AGED`: age group 65 and above, `TOTAL`: all age group, and `DEPENDENCY`: the ratio between young and aged against economy active group

### 3.2 Data Wrangling

```{r}
popdata2024 <- popdata %>%
  group_by(PA, SZ, AG) %>%
  summarise(`POP` = sum(`Pop`)) %>%
  ungroup()%>%
  pivot_wider(names_from=AG, 
              values_from=POP) %>%
  mutate(YOUNG = rowSums(.[3:6])
         +rowSums(.[12])) %>%
mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+
rowSums(.[13:15]))%>%
mutate(`AGED`=rowSums(.[16:21])) %>%
mutate(`TOTAL`=rowSums(.[3:21])) %>%  
mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)
/`ECONOMY ACTIVE`) %>%
  select(`PA`, `SZ`, `YOUNG`, 
       `ECONOMY ACTIVE`, `AGED`, 
       `TOTAL`, `DEPENDENCY`)
```

## 4 Joining attribute data with geospatial data

First, convert values in PA and SZ fields to uppercase.

```{r}
popdata2024 <- popdata2024 %>%
  mutate_at(.vars = vars(PA, SZ), 
          .funs = list(toupper)) %>%
  filter(`ECONOMY ACTIVE` > 0)
```

Next, left_join() of dplyr is used to join the geographical data and attribute table using planning subzone name.

```{r}
mpsz_pop2024 <- left_join(mpsz, popdata2024,
                          by = c("SUBZONE_N" = "SZ"))
```

```{r}
write_rds(mpsz_pop2024, "data/rds/mpsz_pop2024.rds")
```

## 5 Choropleth Mapping Geospatial Data

### 5.1 Method 1: Plot choropleth quickly using qtm()

-   tmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.
-   fill argument is used to map the attribute (i.e. DEPENDENCY)

```{r}
tmap_mode("plot")
qtm(shp = mpsz_pop2024, 
    fill = "DEPENDENCY")
```

### 5.2 Method 2: Create choropleth map using tmap elements

-   `quantile`: Quantile classification divides the data into groups where each group has (roughly) the same number of observations.
-   If the values are decimals, the interval range will be shown as decimals.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                n = 5,
                values = "brewer.blues"),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_title("Distribution of Dependency Ratio by planning subzone") +
  tm_layout(frame = TRUE) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))
```

## 6 Drawing a base map

Drawing the planning subzone polygons.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons()
```

### 6.1 Drawing a choropleth map

Assign target variable `Dependency` to tm_polygons.

```{r}
tm_shape(mpsz_pop2024)+
  tm_polygons(fill = "DEPENDENCY")
```

Drawing a choropleth map using tm_fill() only.

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY")
```

Drawing a choropleth map using tm_fill() and tm_border().

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY") +
  tm_borders()
```

-   `fill_alpha`: Used to define transparency of fill
-   `col`: Used to define border color
-   `lwd`: Used to define border line width
-   `lty`: Used to define border line type

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY") +
  tm_borders(col = "grey60",
             lwd = 0.1,
             lty = "dashed")
```

## 7 Data Classification Methods of tmap

Using a quantile of 5 intervals.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```

Using equal data classification based on interval values.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "equal",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```

### 7.1 Additional data classification methods

`kmeans` uses k-means clustering to group similar values.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "kmeans",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```

`headtails` creates breaks based on the head/tails breaks method, good for heavily skewed data.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "headtails",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```

Trying equal classification with 2 classes.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "equal",
                n = 2)) +
  tm_borders(fill_alpha = 0.5)
```

Trying equal classification with 10 classes.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "equal",
                n = 10)) +
  tm_borders(fill_alpha = 0.5)
```

### 7.2 Plotting choropleth map with custom breaks

```{r}
summary(mpsz_pop2024$DEPENDENCY)
```

```{r}
tm_shape(mpsz_pop2024)+
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00))) +
  tm_borders(fill_alpha = 0.5)
```

## 8 Colour Scheme

Changing the colour of the plot.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "brewer.greens")) +
  tm_borders(fill_alpha = 0.5)
```

Add "-" in front of the values, to reverse colour shading order.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) +
  tm_borders(fill_alpha = 0.5)
```

## 9 Cartographic Furniture

Add map furniture such as compass, scale bar and grid lines.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & singstat",
             position = c("left", "bottom"))
```

### 9.1 Map Layout

Map layout refers to the combination of all map elements into a cohensive map. It includes the map background, frame, typography, scale, aspect ratio, margins, and more.

### 9.2 Map Legend

Legend style can be changed.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_pos_auto_in() +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & singstat",
             position = c("left", "bottom"))
```

### 9.3 Map Style

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) + 
  tm_borders(fill_alpha = 0.5) + 
  tmap_style("natural")
```

Reset to default style.

```{r}
tmap_style("white")
```

## 10 Small Multiple Choropleth Maps (Facet Maps)

### 10.1 Method 1: Assign multiple values to at least one of the aesthetic arguments

```{r}
tm_shape(mpsz_pop2024) + 
  tm_polygons(
    fill = c("YOUNG", "AGED"),
    fill.legend = 
      tm_legend(position = tm_pos_in(
        "right", "bottom")),
    fill.scale = tm_scale_intervals(
      style = "equal", 
      n = 5,
      values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tmap_style("natural")
```

### 10.2 Method 2: Arrange multiples choropleth maps in a grid layout

```{r}
youngmap <- tm_shape(mpsz_pop2024)+ 
  tm_polygons(fill = "YOUNG",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                  item.height = 0.8),
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of young population")
                
agedmap <- tm_shape(mpsz_pop2024)+ 
  tm_polygons(fill = "AGED",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                item.height = 0.8),
              fill.scale = tm_scale_intervals(
              style = "quantile", 
              values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of aged population")

tmap_arrange(youngmap, agedmap, asp=1, ncol=2)
```

### 10.3 Method 3: By defining a group-by variable in tm_facets()

```{r}
tm_shape(mpsz_pop2024) +
  tm_fill(fill = "DEPENDENCY",
          fill.scale = tm_scale_intervals(
            style = "quantile",
            values = "brewer.blues")) + 
  tm_facets(by = "REGION_N",
            nrow = 2, 
            ncols = 3,
            free.coords=TRUE, 
            drop.units=TRUE) +
  tm_layout(legend.show = TRUE,
            title.position = c("center", "center"), 
            title.size = 20) +
  tm_borders(fill_alpha = 0.5)
```

## 11 Plotting a choropleth map based on a selected region

Using filter() to filter to "Central Region".

```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.greens"),
              fill.legend = tm_legend()) +
  tm_borders(fill_alpha = 0.5)
```

### 11.1 Complementing Thematic Map with Statistical Chart

```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.greens"),
              fill.legend = tm_legend(),
              fill.chart = tm_chart_box()) +
  tm_borders() +
  tm_layout(asp = 0.8)
```

Label the outliers in the map.

```{r}
mpsz_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")

stats <- boxplot.stats(mpsz_selected$DEPENDENCY)

outlier_vals <- stats$out

outlier_sf <- mpsz_selected[mpsz_selected$DEPENDENCY %in% outlier_vals, ]

tm_shape(mpsz_selected) +
  tm_polygons(fill = "DEPENDENCY",
          fill.scale = tm_scale_intervals(
            style = "quantile", 
            values = "brewer.blues"),
          fill.legend = tm_legend(),
          fill.chart = tm_chart_box()) +
  tm_borders(fill_alpha = 0.5) +
tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2) +
  tm_text("SUBZONE_N", col = "red", size = 0.7) +
  tm_layout(asp = 0.8)
```

## 12 Creating Interactive Map

Features include the ability to zoom in and out, pan across areas, click on locations for more information.

```{r}
region_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")
region_bbox <- st_bbox(region_selected)

stats <- boxplot.stats(region_selected$DEPENDENCY)
outlier_vals <- stats$out
outlier_sf <- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]

tmap_mode("view")
tm_shape(region_selected, 
         bbox = region_bbox) +
  tm_fill("DEPENDENCY",
          id = "SUBZONE_N",
          popup.vars = c(
            "Name" = "SUBZONE_N", 
            "Dependency" = "DEPENDENCY")) +
  tm_borders() +
  tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2)
```

```{r}
tmap_mode("plot")
```

Zoom into the selected region.

```{r}
region_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")
region_bbox <- st_bbox(region_selected)

stats <- boxplot.stats(region_selected$DEPENDENCY)
outlier_vals <- stats$out
outlier_sf <- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]

tmap_mode("view")

tm_shape(region_selected, 
         bbox = region_bbox) +
  tm_fill("DEPENDENCY",
          id = "SUBZONE_N",
          popup.vars = c(
            "Name" = "SUBZONE_N", 
            "Dependency" = "DEPENDENCY")) +
  tm_borders() +
  tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2) +
  tm_view(set_zoom_limits = c(12,14))
```
